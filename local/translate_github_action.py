import argparse
import os
import yaml
import re


def Header(action_path):
    return f"# DO NOT MODIFY: Auto-generated by the gen_installer.py script from the {action_path} Github Action"


def ConvertStep(step, system):
    if step.get("uses", "").startswith("actions/checkout") and "with" in step:
        args = step["with"]
        script = "git clone"
        if "repository" in args:
            script += f" https://github.com/{args['repository']}.git"
        if "path" in args:
            script += f" {args['path']}"
        script += " --depth 1"
        if "ref" in args:
            script += f" --branch {args['ref']}"
        script += "\n"
        if "submodules" in args:
            if "path" in args:
                script += f"cd {args['path']}\n"
            script += "git submodule update --init\n"
            if "path" in args:
                script += "cd ..\n"
        return script

    script = ""
    if "env" in step:
        script += OutputEnvironment(step["env"], system)
        script += "\n\n"
    script += step.get("run", "")
    return script


def ShellExtension(system):
    if "windows" in system:
        return "ps1"
    else:
        return "sh"


def OutputEnvironment(env, system):
    if "windows" in system:
        exports = [f'$env:{name} = "{value}"' for name, value in env.items()]
    else:
        exports = [f'export {name}="{value}"' for name, value in env.items()]
    return "\n".join(exports)


GITHUB_ACTIONS_VAR = re.compile(r"\$\{\{(.+?)\}\}")


def SubstituteVariablesSingleCommand(input, env, workflow_inputs=dict()):
    if type(input) != str:
        return input

    def FindVar(match):
        name = match.group(1).split(".")[-1]
        if name in workflow_inputs:
            return workflow_inputs[name]
        if name in env:
            return env[name]
        return f"${name}"

    return GITHUB_ACTIONS_VAR.sub(FindVar, input)


def SubstituteVariables(action, env, workflow_inputs=dict()):
    result = dict()
    for key in action:
        if type(action[key]) == dict:
            result[key] = SubstituteVariables(action[key], env, workflow_inputs)
        elif type(action[key]) == list:
            result[key] = [
                SubstituteVariables(command, env, workflow_inputs)
                for command in action[key]
            ]
        else:
            result[key] = SubstituteVariablesSingleCommand(
                action[key], env, workflow_inputs
            )
    return result


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="Generate xpano installer script from a Github Action"
    )
    parser.add_argument("action_path", help="Path to the Github Action YAML file")
    parser.add_argument("--output_dir", help="Output directory", default=".")
    parser.add_argument("--tag", help="Tag of the release", required=True)
    args = parser.parse_args()

    with open(args.action_path, "r") as file:
        action = yaml.safe_load(file)

    env = action.get("env", {})
    workflow_inputs = {"tag": args.tag}
    action = SubstituteVariables(action, env, workflow_inputs)

    for job_name, job in action["jobs"].items():
        system = job["runs-on"]
        filename = "{}.{}".format(job_name, ShellExtension(system))

        header = Header(args.action_path)
        exports = OutputEnvironment(env, system)
        script = "\n".join(ConvertStep(step, system) for step in job["steps"])

        with open(os.path.join(args.output_dir, filename), "w") as file:
            file.write(header)
            file.write("\n\n")
            file.write(exports)
            file.write("\n\n")
            file.write(script)
